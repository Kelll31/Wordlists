# Волшебные хэши PHP

В PHP есть несколько уникальных функций, которые упрощают "коллизию" хэшей при использовании `==` для сравнения.

Исходный текст взят непосредственно из [spaze/hashes](https://github.com/spaze/hashes/)

- - -

### Плавающее сравнение

Любые строки, которые начинаются с любых цифр, начиная с "0", за которыми следует "e", и заканчиваются только цифрами, будут рассматриваться как нулевые. Примером таких строк являются "0e123456" и "00e123456`. [Пример кода](https://3v4l.org/n8iOp)

Это поведение может быть распространено на числа, например `0' == '000". [Пример кода](https://3v4l.org/K9QRb)

При свободном сравнении `==` эти две строки в качестве примера будут приравниваться друг к другу, поскольку обе они обрабатываются как нулевые в серверной части.

Иногда хэши определенных строк приводят к появлению этих специальных строк. Такие хэши называются `магическими хэшами`

Вот пример такого слабого сравнения для [sha256](https://3v4l.org/Lu7tm).

- - -

### Открытый текст

Plaintext.txt просто содержит несколько способов злоупотребления слабым сравнением в php

- - -

### Усеченный текст

В bcrypt пароли автоматически сокращаются до 72 символов, поэтому, если совпадают первые 72 символа, хэши будут совпадать.

[Пример Bcrypt](https://3v4l.org/MsfS0)

Функция Descrypt работает аналогично функции bcrypt, но вместо этого пароли усекаются до 8 символов.

- - -

## Предварительно хэшированный

<!--- Изменено с https://github.com/spaze/hashes?tab%253Dreadme-ov-file#pbkdf2-hmac-sha1-pbkdf2-hmac-sha224-pbkdf2-hmac-sha256-->

Это другой вид магических хэшей, они не нуждаются в свободном операторе сравнения "==" и работают даже при строгом сравнении "===".

Если вы используете пароль длиной более 64 байт и хэшируете его с помощью PBKDF2-HMAC-SHA1, он сначала предварительно хэшируется с помощью SHA1.

Например, `PBKDF2-HMAC-SHA1(пароль 1) === PBKDF2-HMAC-SHA1(пароль 2)` как `sha1(пароль 1) === bin2hex(пароль 2)`.

Такое поведение также можно увидеть в `PBKDF2-HMAC-SHA224` и `PBKDF2-HMAC-SHA256`.